#include <stdio.h>

#include "parser.h"
#include "front.h"

static void error();
static void match(int token); /* New helper function */

/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the 
 * textbook 
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages. 
 * Pearson, 10th edition.
 *
 * Modified to include parsing for Java's for-statement
 *
 * EBNF Rule for Java's for-statement:
 * <for-statement> ::= "for" "(" [<for-init>] ";" [<expression>] ";" [<for-update>] ")" <statement>
 * <for-init> ::= <local-variable-declaration> | <statement-expression-list>
 * <for-update> ::= <statement-expression-list>
 * <statement-expression-list> ::= <statement-expression> {"," <statement-expression>}
 * <local-variable-declaration> ::= <type> <variable-declarators>
 */

/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */
void expr() 
{
    printf("Enter <expr>\n");

    /* Parse the first term */
    term();

    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
        term();
    }

    printf("Exit <expr>\n");
} /* End of function expr */

/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term() 
{
    printf("Enter <term>\n");
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP) {
            lex();
            factor();
    }
    printf("Exit <term>\n");
} /* End of function term */

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr )
 * */
void factor() 
{
    printf("Enter <factor>\n");
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT) {
        lex(); /* Get the next token */
    } else {
        /* If the RHS is (<expr>), call lex to pass over the 
        left parenthesis, call expr, and check for the right 
        parenthesis */
        if (nextToken == LEFT_PAREN) {
            lex(); 
            expr();

            if (nextToken == RIGHT_PAREN) {
                lex(); 
            } else { 
                error();
            }
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left parenthesis */
        else 
        { 
            error(); 
        }
    } /* End of else */
    printf("Exit <factor>\n");;
} /* End of function factor */

/* helper function to match and consume expected tokens */
static void match(int token) {
    if (nextToken == token) {
        lex();
    } else {
        error();
    }
}

/* for_statement
 * Parses strings in the language generated by the rule:
 * <for-statement> ::= "for" "(" [<for-init>] ";" [<expression>] ";" [<for-update>] ")" <statement>
 */
void for_statement() {
    printf("Enter <for-statement>\n");
    
    /* Match "for" */
    match(FOR_CODE);
    
    /* Match "(" */
    match(LEFT_PAREN);
    
    /* [<for-init>] - Optional initialization */
    if (nextToken != ';') {
        /* We would call the appropriate parsing function here
           for the initialization, which could be a variable declaration
           or an expression. For simplicity, we'll just consume tokens
           until we reach the first semicolon. */
        while (nextToken != ';') {
            lex();
        }
    }
    
    /* Match ";" after initialization */
    match(';');
    
    /* [<expression>] - Optional condition */
    if (nextToken != ';') {
        expr();
    }
    
    /* Match ";" after condition */
    match(';');
    
    /* [<for-update>] - Optional update */
    if (nextToken != RIGHT_PAREN) {
        /* Similar to initialization, we'd parse the update expressions.
           For simplicity, we'll just consume tokens until we reach
           the right parenthesis. */
        while (nextToken != RIGHT_PAREN) {
            lex();
        }
    }
    
    /* Match ")" */
    match(RIGHT_PAREN);
    
    /* <statement> - The loop body */
    statement();
    
    printf("Exit <for-statement>\n");
}

/* statement
 * Parses a single statement, which could be a simple statement
 * or a compound statement (block).
 */
void statement() {
    printf("Enter <statement>\n");
    
    /* In a more complete parser, we would check for different
       statement types here and call the appropriate parsing function.
       For simplicity, we'll just handle a few cases. */
    
    if (nextToken == LEFT_PAREN) {
        /* A block of statements enclosed in braces */
        match(LEFT_PAREN);
        
        /* Parse statements until we reach the closing brace */
        while (nextToken != RIGHT_PAREN) {
            statement();
        }
        
        match(RIGHT_PAREN);
    } else if (nextToken == FOR_CODE) {
        /* A nested for statement */
        for_statement();
    } else {
        /* A simple statement ending with a semicolon */
        while (nextToken != ';') {
            lex();
        }
        match(';');
    }
    
    printf("Exit <statement>\n");
}

static void error() 
{
    printf("Error (more is desired, but not implemented).\n");
}