#include <stdio.h>

#include "parser.h"
#include "front.h"

static void error();
static void match(int token); /* New helper function */

/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the 
 * textbook 
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages. 
 * Pearson, 10th edition.
 *
 ***********************************************************************************************************************
 * EBNF Rule for Java's for-statement:
 * <for-statement> ::= "for" "(" [<for-init>] ";" [<expression>] ";" [<for-update>] ")" <statement>
 * <for-init> ::= <local-variable-declaration> | <statement-expression-list>
 * <for-update> ::= <statement-expression-list>
 * <statement-expression-list> ::= <statement-expression> {"," <statement-expression>}
 * <local-variable-declaration> ::= <type> <variable-declarators>
 * *********************************************************************************************************************
 */

/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */
void expr() 
{
    printf("Enter <expr>\n");

    /* Parse the first term */
    term();

    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
        term();
    }

    printf("Exit <expr>\n");
} /* End of function expr */

/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term() 
{
    printf("Enter <term>\n");
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP) {
            lex();
            factor();
    }
    printf("Exit <term>\n");
} /* End of function term */

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr )
 * */
void factor() 
{
    printf("Enter <factor>\n");
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT) {
        lex(); /* Get the next token */
    } else {
        /* If the RHS is (<expr>), call lex to pass over the 
        left parenthesis, call expr, and check for the right 
        parenthesis */
        if (nextToken == LEFT_PAREN) {
            lex(); 
            expr();

            if (nextToken == RIGHT_PAREN) {
                lex(); 
            } else { 
                error();
            }
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left parenthesis */
        else 
        { 
            error(); 
        }
    } /* End of else */
    printf("Exit <factor>\n");;
} /* End of function factor */

/* helper function to match and consume expected tokens */
static void match(int token) {
    if (nextToken == token) {
        lex();
    } else {
        error();
    }
}

/* for_statement
 * My implementation of Java's for-statement parser
 * Based on: for(init; condition; update) statement
 */
void for_statement() {
    printf("Enter <for-statement>\n");
    
    /* Gotta match 'for' first */
    match(FOR_CODE);
    
    match(LEFT_PAREN);
    
    /* Handle the init part if it exists */
    if (nextToken != ';') {
        /* Just eating tokens for now - should be more complex later */
        while (nextToken != ';') {
            lex();
        }
    }
    
    match(';');
    
    /* Need to handle the middle condition part */
    if (nextToken != ';') {
        expr();
    }
    
    match(';');
    
    /* Last part before the closing paren */
    if (nextToken != RIGHT_PAREN) {
        /* Just eat tokens again for simplicity */
        while (nextToken != RIGHT_PAREN) {
            lex();
        }
    }
    
    match(RIGHT_PAREN);
    
    /* Now parse whatever statement makes up the loop body */
    statement();
    
    printf("Exit <for-statement>\n");
}

/* statement
 * Need this to handle both simple and compound statements
 */
void statement() {
    printf("Enter <statement>\n");
    
    if (nextToken == LEFT_PAREN) {
        /* Got a block with multiple statements inside */
        match(LEFT_PAREN);
        
        while (nextToken != RIGHT_PAREN) {
            statement();
        }
        
        match(RIGHT_PAREN);
    } else if (nextToken == FOR_CODE) {
        /* Another for loop inside this statement */
        for_statement();
    } else {
        /* Just a regular statement ending with semicolon */
        while (nextToken != ';') {
            lex();
        }
        match(';');
    }
    
    printf("Exit <statement>\n");
}

static void error() 
{
    printf("Error (more is desired, but not implemented).\n");
}



/*
The output: 

Next token is: 25, Next lexeme is (
Enter <expr>
Enter <term>
Enter <factor>
Next token is: 11, Next lexeme is sum
Enter <expr>
Enter <term>
Enter <factor>
Next token is: 21, Next lexeme is +
Exit <factor>
Exit <term>
Next token is: 10, Next lexeme is 47
Enter <term>
Enter <factor>
Next token is: 26, Next lexeme is )
Exit <factor>
Exit <term>
Exit <expr>
Next token is: 24, Next lexeme is /
Exit <factor>
Next token is: 11, Next lexeme is total
Enter <factor>
Next token is: -1, Next lexeme is EOF
Exit <factor>
Exit <term>
Exit <expr>
...Program finished with exit code 0
Press ENTER to exit console.
*
*/